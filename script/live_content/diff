#!/usr/bin/env ruby

# Start Content Store and Publishing API before running this script

require "English"
require "fileutils"
require "json"
require "net/http"
require "uri"

# Using a list of base paths, render each page with Content Store and Publishing
# API's GraphQL endpoint as the data source and diff the results.

OUTPUT_DIR = "tmp/diffs/content_items".freeze

FileUtils.mkdir_p(OUTPUT_DIR)

def usage
  abort("Usage:\n\t#{$PROGRAM_NAME} a_base_path")
end

DATE_PATTERN = /^\d{4}-\d{2}-\d{2}/

base_path = ARGV.fetch(0) { usage }

publishing_api_uri = URI("http://publishing-api.dev.gov.uk/graphql/content#{base_path}")
content_store_uri = URI("http://content-store.dev.gov.uk/content#{base_path}")

def deep_sort(value)
  if value.is_a?(Hash)
    value.transform_values { deep_sort(_1) }.sort.to_h
  elsif value.is_a?(Array)
    value.map(&method(:deep_sort))
  else
    value
  end
end

def deep_prune_hash(hash)
  hash.map { deep_prune(_1, _2) }.compact.to_h
end

def deep_prune(key, value)
  case [key, value]
  in [String, Hash]
    [key, deep_prune_hash(value)]
  in [String, [Hash, *]]
    [key, value.map(&method(:deep_prune_hash))]
  in ["withdrawn", *]
    nil
  in [String, DATE_PATTERN]
    [key, value.sub(/(#{DATE_PATTERN}).*/, '\1')]
  else
    [key, value]
  end
end

def get_json(uri)
  JSON
    .pretty_generate(deep_prune_hash(deep_sort(JSON.parse(Net::HTTP.get(uri)))))
    .gsub(/,$/, "")
end

publishing_api_json = get_json(publishing_api_uri)
content_store_json = get_json(content_store_uri)

publishing_api_file_path = File.join(OUTPUT_DIR, "publishing_api_response.json")
content_store_file_path = File.join(OUTPUT_DIR, "content_store_response.json")

File.write(publishing_api_file_path, publishing_api_json)
File.write(content_store_file_path, content_store_json)

puts `diff --color=always -u #{content_store_file_path} #{publishing_api_file_path}`

exit $CHILD_STATUS.exitstatus
